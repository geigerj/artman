#!/usr/bin/env python

# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
CLI entry point to artman for basic use cases.

This triggers remote execution of artman. For more advanced customization, use
`execute_pipeline.py`. For usage, pass the `-h` flag at the command line.
"""

import argparse
import collections
import os
from os import path
import re
import shutil
import tarfile
import tempfile

import execute_pipeline


# Valid ways of invoking artman
_VALID_COMMANDS = ['GapicConfig',
                   'Library',
                   'Docs']


# Languages supported by artman
_LANGUAGES = ['java',
              'python',
              'go',
              'csharp',
              'php',
              'ruby',
              'nodejs']


# Regular expression matching the package declaration for a proto file
_PROTO_PKG = re.compile(r'^package ([A-Za-z_]+(\.[A-Za-z_0-9]+)*)')


# The group of _PROTO_PKG regexp matching the actual package name
_PROTO_PKG_GROUP = 1


def _parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-n',
        '--name',
        type=str,
        help='the name of the API, e.g., google-logging-v2. If not specified, '
              'is automatically derived from the argument of the first '
              '--services_root/-r flag.')
    parser.add_argument(
        '-l',
        '--language',
        nargs='+',
        type=str,
        action='append',
        help='The language to generate for. Can take multiple arguments or be '
             'repeated. If not specified, defaults to all available '
             'languages.')
    parser.add_argument(
        '-o',
        '--output',
        type=str,
        help='The output directory. This defaults the first path argument '
             'specified for GAPIC config generation, and to the current '
             'directory for other commands.')
    parser.add_argument(
        '-g',
        '--gapic_config',
        type=str,
        help='The configuration file for GAPIC generation. This is typically '
             'autogenerated by artman and so does not need to be specified '
             'unless being overridden.')
    parser.add_argument(
        '-p',
        '--proto_path',
        action='append',
        nargs='+',
        type=str,
        required=True,
        help='The directory containing the service proto definitions. Can '
             'be repeated.')
    parser.add_argument(
        '-s',
        '--service_config',
        type=str,
        required=True,
        help='The API\'s service config file, in YAML format.')
    parser.add_argument(
        '-c',
        '--command',
        type=str,
        action='append',
        nargs='+',
        required=True,
        help='The action to take. Can be chained, but order is important. '
             'Available commands are: [' + ', '.join(_VALID_COMMANDS) + '] '
             'Note that the `Docs` command is available only for '
             'Python, Ruby, and NodeJS.')
    return parser.parse_args()


def _normalize_args(args):
    """Flatten nested argument lists and make languages case-insensitive."""
    if not args.language:
        args.language = _LANGUAGES
    else:
        args.language = [l.lower() for lst in args.language for l in lst]
    args.command = [cmd for lst in args.command for cmd in lst]
    args.proto_path = [pth for lst in args.proto_path for pth in lst]
    args.output = args.output or os.getcwd()


def _verify_args(args):
    for command in args.command:
        if command not in _VALID_COMMANDS:
            raise ValueError('Invalid command: {}'. format(command))
    for language in args.language:
        if language not in _LANGUAGES:
            raise ValueError('Unrecognized language: {}'.format(language))
    if not path.isfile(args.service_config):
        raise ValueError(
            'Service config file not found: {}'.format(args.service_config))
    if args.gapic_config and not path.isfile(args.gapic_config):
        raise ValueError(
            'GAPIC config file not found: {}'.format(args.gapic_config))
    for pth in args.proto_path:
        if not path.isdir(pth):
            raise ValueError('Input directory not found: {}'.format(pth))
    if not path.isdir(args.output):
        os.makedirs(args.output)


def _find_protos(pth):
    for root, _, files in os.walk(pth):
        for a_file in files:
            print 'checking ' + root
            if path.splitext(a_file)[1] == '.proto':
                print 'found ' + a_file
                yield path.join(root, a_file)


def _copy_protos(pth, dst):
    """Find protos on path, copy to subdirectory in dst based on package.
    Return the dirs to which they were copied under `dst`."""
    packages = set()
    for proto in _find_protos(pth):
        package = ''
        with open(proto) as f:
            for line in f:
                match = _PROTO_PKG.match(line)
                if match:
                    package = match.group(_PROTO_PKG_GROUP).replace('.', '/')
                    packages.add(package)
                    break

            final_dst = path.join(dst, package)
            if not os.path.exists(final_dst):
                os.makedirs(final_dst)
            shutil.copy(proto, final_dst)
    return packages


# TODO: use settings from lang section of googleapis/gapic/lang/common.yaml
def _create_base_pipeline_kwargs(args):
    """Configures pipeline- and language-independent pipeline arguments."""
    pipeline_kwargs = {}

    srcs = set()
    local_dir = tempfile.mkdtemp(prefix='artman' + os.sep)
    print 'local_repo is being constructed in: {}'.format(local_dir)

    for pth in args.proto_path:
        srcs |= _copy_protos(pth, local_dir)
    pipeline_kwargs['src_proto_path'] = [
        '${{REPOROOT}}/googleapis/{}'.format(src) for src in srcs]

    if args.name:
        pipeline_kwargs['api_name'] = args.name
    else:
        pipeline_kwargs['api_name'] = path.dirname(args.service_config).split(
            os.sep)[-1]

    shutil.copy(args.service_config, local_dir)
    pipeline_kwargs['service_yaml'] = [
        '${{REPOROOT}}/googleapis/{}'.format(
            os.path.basename(args.service_config))]

    if args.gapic_config:
        shutil.copy(args.gapic_config, local_dir)
        pipeline_kwargs['gapic_api_yaml'] = [
            '${{REPOROOT}}/googleapis/{}'.format(
                os.path.basename(args.gapic_config))]
    else:
        pipeline_kwargs['gapic_api_yaml'] = [path.splitext(
            pipeline_kwargs['service_yaml'][0])[0] + '_gapic.yaml']

    # Args that aren't configurable via this CLI entry point
    pipeline_kwargs['import_proto_path'] = ['${REPOROOT}/googleapis']
    pipeline_kwargs['output_dir'] = '${REPOROOT}/artman/output'
    pipeline_kwargs['final_repo_dir'] = '${REPOROOT}/final_output'
    pipeline_kwargs['toolkit_path'] = '${REPOROOT}/toolkit'
    
    return pipeline_kwargs, local_dir


def _generate_pipelines(args):
    pipelines = []
    base_pipeline_kwargs, local_dir = _create_base_pipeline_kwargs(args)

    print 'commands: {}'.format(args.command)
    for command in args.command:
            # config
            if command == _VALID_COMMANDS[0]:
                pipelines.append(
                    _config_pipeline(base_pipeline_kwargs, args.output))
            # library
            elif command == _VALID_COMMANDS[1]:
                for lang in args.language:
                    pipelines.append(_grpc_pipeline(
                        lang, base_pipeline_kwargs, args.output))
                    pipelines.append(_gapic_pipeline(
                        lang, base_pipeline_kwargs, args.output))
            # docs
            else:
                for lang in args.language:
                    pipelines.append(
                        _doc_pipeline(lang, base_pipeline_kwargs, args.output))
    return pipelines, local_dir


class _Pipeline(collections.namedtuple(
        'Pipeline', ['name', 'language', 'args', 'out'])):
    pass


def _config_pipeline(pipeline_kwargs, out):
    return _Pipeline('GapicConfigPipeline', None, pipeline_kwargs, pipeline_kwargs['gapic_api_yaml'])


def _grpc_pipeline(lang, pipeline_kwargs, out):
    return _Pipeline('GrpcClientPipeline', lang, pipeline_kwargs,
                     pipeline_kwargs['final_repo_dir'])


# TODO: derive gapic_language_yaml from
#   googleapis/gapic/lang/common.yaml
# if that file becomes available in the artman codebase
def _gapic_pipeline(lang, pipeline_kwargs, out):
    pipeline_kwargs = pipeline_kwargs.copy()
    pipeline_kwargs['gapic_language_yaml'] = [
        '${{REPOROOT}}/googleapis/gapic/lang/{}_gapic.yaml'.format(lang)]
    return _Pipeline('GapicClientPipeline', lang, pipeline_kwargs,
                     pipeline_kwargs['final_repo_dir'])


# TODO: derive gapic_language_yaml from
#   googleapis/gapic/lang/doc.yaml
# if that file becomes available in the artman codebase
def _doc_pipeline(lang, pipeline_kwargs, out):
    pipeline_kwargs = pipeline_kwargs.copy()
    pipeline_kwargs['gapic_language_yaml'] = [
        '${{REPOROOT}}/googleapis/gapic/lang/{}_doc.yaml'.format(lang)]
    return _Pipeline('GapicClientPipeline', lang, pipeline_kwargs,
                     pipeline_kwargs['final_repo_dir'])


def _execute_pipeline(
        pipeline, local_dir, out_dst):
    print 'triggering artman execution for pipeline {}'.format(pipeline.name)
    # TODO: these fields should be shared with execute_pipeline.py so that
    # a flag exists in artman.py iff it exists in execute_pipeline.py
    flags = argparse.Namespace()
    flags.pipeline_kwargs = str(pipeline.args)
    flags.pipeline_name = pipeline.name
    flags.local_repo = local_dir
    flags.env = 'jgeiger15' # FIXME: remote or override
    flags.config = None
    flags.reporoot = '..'
    flags.language = pipeline.language or None
    flags.stage_output = False
    
    archive = execute_pipeline.run_from_flags(flags)
    archive_path = pipeline.args['final_repo_dir'].replace('${REPOROOT}/', '')
    
    return local_dir, archive, archive_path, os.path.join(out_dst, 'artman')


def _copy_output(local_dir, archive, archive_path, dst):
    # TODO: permit artman to return a specific path within final_repo_dir
    # so that it is possible to retrieve a more limited subset of the output
    # (e.g., only the client library, or only the GAPIC config)
    extracted_dir = os.path.join(local_dir, 'downloaded_output')
    with tarfile.open(archive, 'r') as tf:
        tf.extractall(extracted_dir)
    shutil.copytree(os.path.join(extracted_dir, archive_path), dst)
    
        

if __name__ == '__main__':
    args = _parse_args()
    _normalize_args(args)
    _verify_args(args)
    pipelines, local_dir = _generate_pipelines(args)
    print pipelines
    for pipeline in pipelines:
        _copy_output(*_execute_pipeline(
            pipeline,
            local_dir,
            args.output))
